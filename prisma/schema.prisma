// User: Содержит статусы активности обменника и систему заморозки

// Balance System: Отдельные модели для баланса и холдов

// Transaction Lifecycle: Детальное отслеживание статусов сделки

// Dispute System: Полная цепочка работы со спорами

// Review System: Система отзывов с привязкой к завершенным сделкам

// Time-based Logic: Поля для контроля временных ограничений (30-минутные таймеры)


generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model User {
  id                String         @id @default(uuid())
  email             String         @unique
  password          String
  name              String
  role              UserRole       @default(CUSTOMER)
  isExchangerActive Boolean        @default(false)
  isFrozen          Boolean        @default(false)
  frozenUntil       DateTime?
  missedOffersCount Int            @default(0)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relationships
  listings          ExchangeListing[]
  offers            ExchangeOffer[]
  exchangerTransactions ExchangeTransaction[] @relation("ExchangerTransactions")
  customerTransactions  ExchangeTransaction[] @relation("CustomerTransactions")
  disputesInitiated  Dispute[]               @relation("DisputeInitiator")
  disputesModerated  Dispute[]               @relation("DisputeModerator")
  reviewsWritten     Review[]                @relation("ReviewAuthor")
  reviewsReceived    Review[]                @relation("ReviewTarget")
  balance           UserBalance?
  exchangerSettings ExchangerSettings?
  holds             BalanceHold[]
  auditLogs         AuditLog[]
  exchangerStatus   ExchangerStatus?
  messages          Message[]
  chatParticipants  ChatParticipant[]
  comments          Comment[]

  @@index([isExchangerActive])
  @@index([isFrozen])

  @@map("users")
}

enum UserRole {
  CUSTOMER
  EXCHANGER
  ADMIN
  MODERATOR
}

model ExchangeListing {
  id              String           @id @default(uuid())
  type            ExchangeType
  cryptocurrency  String
  fiatCurrency    String
  rate            Float
  minAmount       Float
  maxAmount       Float
  availableAmount Float
  paymentMethods  PaymentMethod[]
  terms           String?
  userId          String
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relationships
  user            User             @relation(fields: [userId], references: [id])
  offers          ExchangeOffer[]
  transactions    ExchangeTransaction[]

  @@index([type])
  @@index([isActive])
  @@index([userId])
  @@map("exchange_listings")
}

enum ExchangeType {
  CRYPTO_TO_FIAT
  FIAT_TO_CRYPTO
}

enum PaymentMethod {
  BANK_TRANSFER
  PAYPAL
  WISE
  CASH
  // Добавьте другие методы по необходимости
}

model ExchangeOffer {
  id              String           @id @default(uuid())
  amount          Float
  status          TransactionStatus @default(PENDING)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relationships
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  listingId       String
  listing         ExchangeListing  @relation(fields: [listingId], references: [id])
  transaction     ExchangeTransaction?

  @@index([status])
  @@index([userId])
  @@index([listingId])
  @@map("exchange_offers")
}

enum TransactionStatus {
  PENDING
  APPROVED
  DECLINED
  PAYMENT_CONFIRMED
  RECEIPT_CONFIRMED
  FINISHED
  CANCELLED
  DISPUTE_OPEN
  DISPUTE_RESOLVED
}

model ExchangeTransaction {
  id                String           @id @default(uuid())
  type              ExchangeType
  status            TransactionStatus
  cryptocurrency    String
  fiatCurrency      String
  cryptoAmount      Float
  fiatAmount        Float
  paymentProof      String?
  disputeId         String?
  confirmationDeadline DateTime
  canCustomerDispute  Boolean         @default(true)
  canExchangerDispute Boolean         @default(true)
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  finishedAt        DateTime?

  // Relationships
  offerId           String?         @unique
  offer             ExchangeOffer?  @relation(fields: [offerId], references: [id])
  customerId        String
  customer          User            @relation("CustomerTransactions", fields: [customerId], references: [id])
  exchangerId       String
  exchanger         User            @relation("ExchangerTransactions", fields: [exchangerId], references: [id])
  listingId         String
  listing           ExchangeListing @relation(fields: [listingId], references: [id])
  dispute           Dispute?
  review            Review?

  @@index([status])
  @@index([customerId])
  @@index([exchangerId])
  @@index([confirmationDeadline])
  @@index([isActive])
  @@index([finishedAt])
  @@map("exchange_transactions")
}

model Dispute {
  id              String           @id @default(uuid())
  reason          String
  status          DisputeStatus    @default(OPEN)
  resolution      String?
  resolvedAt      DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relationships
  transactionId   String           @unique
  transaction     ExchangeTransaction @relation(fields: [transactionId], references: [id])
  initiatorId     String
  initiator       User             @relation("DisputeInitiator", fields: [initiatorId], references: [id])
  moderatorId     String?
  moderator       User?            @relation("DisputeModerator", fields: [moderatorId], references: [id])
  chat            Chat?
  comments        Comment[]

  @@index([status])
  @@index([initiatorId])
  @@map("disputes")
}

enum DisputeStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
}

model Review {
  id              String           @id @default(uuid())
  rating          Int
  comment         String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relationships
  transactionId   String           @unique
  transaction     ExchangeTransaction @relation(fields: [transactionId], references: [id])
  authorId        String
  author          User             @relation("ReviewAuthor", fields: [authorId], references: [id])
  targetId        String
  target          User             @relation("ReviewTarget", fields: [targetId], references: [id])

  @@index([authorId])
  @@index([targetId])
  @@map("reviews")
}

model UserBalance {
  id                String    @id @default(uuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id])
  cryptoBalance     Json      // Store balances for different cryptocurrencies
  totalHoldAmount   Json      // Store total held amounts per cryptocurrency
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

model BalanceHold {
  id                String    @id @default(uuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id])
  cryptocurrency    String
  amount            Float
  type              HoldType
  relatedTransactionId String?
  expiresAt         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId])
  @@index([expiresAt])
  @@map("balance_holds")
}

enum HoldType {
  EXCHANGE_OFFER    // Hold for pending exchange offer
  DISPUTE          // Hold during dispute
  SYSTEM           // System-level hold
}

model ExchangerSettings {
  id                String    @id @default(uuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id])
  autoAcceptOffers  Boolean   @default(false)
  preferredPaymentMethods PaymentMethod[]
  workingHours      Json?     // Store working hours for each day
  minimumRating     Float?    // Minimum customer rating to accept
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("exchanger_settings")
}

model AuditLog {
  id          String    @id @default(uuid())
  action      String
  entityType  String
  entityId    String
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  metadata    Json?
  createdAt   DateTime  @default(now())

  @@index([entityType, entityId])
  @@index([userId])
  @@map("audit_logs")
}

model ScheduledTask {
  id          String    @id @default(uuid())
  type        String
  status      TaskStatus @default(PENDING)
  data        Json?
  scheduledAt DateTime
  executedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([type])
  @@index([status])
  @@index([scheduledAt])
  @@map("scheduled_tasks")
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

model ExchangerStatus {
  id            String    @id @default(uuid())
  exchangerId   String    @unique
  online        Boolean   @default(false)
  isFrozen      Boolean   @default(false)
  frozenReason  String?
  lastActivity  DateTime  @default(now())
  exchanger     User      @relation(fields: [exchangerId], references: [id])

  @@map("exchanger_status")
}

model Chat {
  id              String           @id @default(uuid())
  type            ChatType         @default(DISPUTE)
  disputeId       String?          @unique
  dispute         Dispute?         @relation(fields: [disputeId], references: [id])
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relationships
  messages        Message[]
  participants    ChatParticipant[]

  @@index([type])
  @@index([disputeId])
  @@map("chats")
}

model Message {
  id              String           @id @default(uuid())
  content         String
  senderId        String
  sender          User             @relation(fields: [senderId], references: [id])
  chatId          String
  chat            Chat             @relation(fields: [chatId], references: [id])
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([senderId])
  @@index([chatId])
  @@map("messages")
}

model ChatParticipant {
  id              String           @id @default(uuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  chatId          String
  chat            Chat             @relation(fields: [chatId], references: [id])
  role            ChatParticipantRole
  joinedAt        DateTime         @default(now())

  @@unique([userId, chatId])
  @@index([userId])
  @@index([chatId])
  @@map("chat_participants")
}

enum ChatType {
  DISPUTE
  SUPPORT
  GENERAL
}

enum ChatParticipantRole {
  CUSTOMER
  EXCHANGER
  MODERATOR
  ADMIN
}

model Comment {
  id          String    @id @default(uuid())
  disputeId   String
  userId      String
  text        String
  isModerator Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relationships
  dispute     Dispute   @relation(fields: [disputeId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@index([disputeId])
  @@index([userId])
  @@map("comments")
}